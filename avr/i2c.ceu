/*
    // desc here

errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/
#include "../i2c.ceu"
var bool i2c_master = true;

var u8 deviceAddress = 0;
var u8 errorcode=1;
var int requestmode=-1;// 0 for Write and 1 for Read
#define TXMAXBUFLEN 20 // Transmit buffer length
var[TXMAXBUFLEN] byte twi_transmit_buffer;// max buffer length = 20
var[TXMAXBUFLEN] byte twi_receive_buffer;// max buffer length = 20

native/pre do
    ##include <compat/twi.h>
    #include "i2c.h"
end

native
    _TWI_vect,
;   

output (u8 v) I2C_SET_ADDRESS do
    outer.deviceAddress = v;
    {TWAR = @(v) << 1;}
end

output (on/off v) I2C do
    if v then
        {
            TWBR = ((F_CPU / 100000L) - 16) / 2; // Bit rate formula
            TXBuffIndex = 0;
            TXBuffLen = 0;
            RXBuffLen = 0;
            RXBuffIndex = 0;
            digitalWrite(SDA, 1);
            digitalWrite(SCL, 1);
        }
    else
        {
            TXBuffIndex = 0;
            TXBuffLen = 0;
            RXBuffLen = 0;
            RXBuffIndex = 0;
            TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));
            digitalWrite(SDA, 0);
            digitalWrite(SCL, 0);
        }
    end
end

output (u8 address) I2C_REQUEST_SEND do
    // set requestmode as TW_WRITE (0) and send start signal
    outer.requestmode=0;// write mode
    {
        SLA=@address;
        TXBuffIndex = 0;
        TXBuffLen = @($outer.twi_transmit_buffer);
        TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE)|(1<<TWEA);// start condition
    }
end

output (u8 address, u8 n_byte) I2C_REQUEST_RECEIVE do
    // set requestmode as TW_READ (1) and send start signal
    outer.requestmode=1;// read mode
    outer.twi_receive_buffer = [];
    {
        SLA=@address;
        RXBuffIndex = 0;
        RXBuffLen = @n_byte;
        TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE)|(1<<TWEA);// start condition
    }
end

spawn async/isr [_TWI_vect] do

    var bool done = false;
    {
        switch(TW_STATUS){
            case TW_START:
            case TW_REP_START:
                @(outer.errorcode) = 0;
                if(@(outer.requestmode)!=-1){
                    TWDR = (SLA << 1) | @(outer.requestmode); // SLA + Read/Write (Write in this case)
                    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWEA); // Continue Transfer
                }
                else{
                    TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE); // send stop
                    @done=1;
                }
                break;
        
            case TW_MT_SLA_ACK:
            case TW_MT_DATA_ACK:
                if(TXBuffIndex<TXBuffLen){
                    TWDR = @(outer.twi_transmit_buffer[{TXBuffIndex++}]);
                    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWEA);// send ACK
                }
                else{
                    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWSTO) | (1<<TWEA);// send stop
                    @done=1;
                }
                break;
            case TW_MT_SLA_NACK:
            case TW_MT_DATA_NACK:
                @outer.errorcode=2;// in case of slave not connected or receiving NACK from slave or requesting more data from the slave than the amount sent
                @done=1;
                TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE) | (1<<TWEA);
                break;
            default:
                @outer.errorcode=3;
                @done=1;                
                TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE) | (1<<TWEA);//default case sends stop condition
        }
    }
    if done then
        if outer.requestmode != -1 then
            if outer.requestmode == 1 then
                emit I2C_REQUEST_DONE({TXBuffLen},outer.errorcode);
            else
                emit I2C_REQUEST_DONE({RXBuffLen},outer.errorcode);
            end
        else
            emit I2C_REQUEST_DONE(0,outer.errorcode);
        end
        outer.twi_transmit_buffer = [];
    end
end




